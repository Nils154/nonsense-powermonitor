<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonsense Power Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        
        .container {
            width: 100%;
            margin: 0;
            background: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        
        .graphs-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .graph-box {
            flex: 1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .graph-box h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }
        
        .graph-box img {
            width: 100%;
            height: auto;
            border-radius: 5px;
        }
        
        .browse-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .latest-active {
            background: #28a745 !important;
            border-color: #28a745 !important;
            font-weight: bold;
        }
        
        .latest-active:hover {
            background: #218838 !important;
            border-color: #1e7e34 !important;
        }
        
        .status-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .status-card {
            flex: 1;
            min-width: 200px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .status-card h3 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .status-card .value {
            font-size: 2em;
            font-weight: bold;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-info:hover {
            background: #138496;
        }
        
        .message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }
        
        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px;
        }
        
        th.sortable:hover {
            background: #5568d3;
        }
        
        th.sortable::after {
            content: ' ‚Üï';
            position: absolute;
            right: 8px;
            opacity: 0.5;
            font-size: 0.9em;
        }
        
        th.sortable.sort-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }
        
        th.sortable.sort-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .device-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .device-row:hover {
            background-color: #e3f2fd !important;
        }
        
        .device-row.selected {
            background-color: #bbdefb !important;
        }
        
        .device-row.selected .delete-cell {
            display: table-cell !important;
        }
        
        .delete-cell {
            width: 30px;
            padding: 8px;
        }
        
        .delete-cell:hover {
            background-color: #ffebee;
            color: #c62828 !important;
        }
        
        .editable-cell {
            position: relative;
            cursor: text;
        }
        
        .editable-cell:hover {
            background-color: #fff9c4;
        }
        
        .editable-content {
            display: inline-block;
            min-width: 50px;
            cursor: text;
        }
        
        .device-row.selected .editable-cell {
            background-color: #e8f5e9;
        }
        
        .device-row.selected .editable-cell:hover {
            background-color: #c8e6c9;
        }
        
        .device-row.selected .editable-content {
            border-bottom: 1px dashed #4caf50;
        }
        
        .editable-input {
            width: 100%;
            padding: 4px 8px;
            border: 2px solid #2196F3;
            border-radius: 4px;
            font-size: inherit;
            font-family: inherit;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .event-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .event-info p {
            margin: 5px 0;
            color: #333;
        }
        
        input[type="text"], input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Nonsense Power Analyzer</h1>
        <p class="subtitle">Web-based power event analysis and device identification</p>
        
        <div class="status-bar">
            <div class="status-card">
                <h3>Events</h3>
                <div class="value" id="status-events">{% if status.number_of_events == 0 %}0{% else %}0 to {{ status.number_of_events-1 }}{% endif %}</div>
            </div>
            <div class="status-card">
                <h3>Devices</h3>
                <div class="value" id="status-devices">{{ status.n_devices }}</div>
            </div>
            <div class="status-card">
                <h3>Data Since</h3>
                <div class="value" id="status-data-since" data-iso-timestamp="{% if status.first_event %}{{ status.first_event }}{% endif %}">{% if status.first_event %}{{ status.first_event }}{% else %}N/A{% endif %}</div>
            </div>
        </div>
        
        <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
            <div style="display: flex; align-items: center; gap: 8px; background: white; padding: 5px 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <label for="timestamp-input" style="font-weight: 600; color: #333;">Timestamp:</label>
                <input type="text" id="timestamp-input" 
                       placeholder="Jan 5, 4:03am"
                       style="width: 200px; padding: 6px 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 1em;"
                       onchange="updateEventFromTimestamp()" onkeydown="if(event.key==='Enter') updateEventFromTimestamp();">
                <label for="match-distance-input" style="font-weight: 600; color: #333; margin-left: 10px;">Match Distance:</label>
                <input type="number" id="match-distance-input" min="0" step="25" value="500" 
                       style="width: 100px; padding: 6px 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 1em;">
            </div>
        </div>
        
        <div class="graphs-container">
            <div class="graph-box">
                <h3>Timeline</h3>
                <div class="plot-container" style="position: relative; min-height: 400px;">
                    <img id="timeline-plot" src="" alt="Timeline plot" style="display: none; width: 100%; height: auto;">
                    <img id="timeline-plot-new" src="" alt="Timeline plot" style="display: none; width: 100%; height: auto; position: absolute; top: 0; left: 0;">
                    <div id="timeline-loading" class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 400px;">
                        <div class="progress-bar-container" style="width: 100%; background-color: #f0f0f0; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div id="timeline-progress" class="progress-bar" style="width: 0%; height: 30px; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="graph-box">
                <h3>Power Pattern</h3>
                <div class="plot-container" style="position: relative; min-height: 400px;">
                    <img id="power-plot" src="" alt="Power plot" style="display: none; width: 100%; height: auto;">
                    <img id="power-plot-new" src="" alt="Power plot" style="display: none; width: 100%; height: auto; position: absolute; top: 0; left: 0;">
                    <div id="power-loading" class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 400px;">
                        <div class="progress-bar-container" style="width: 100%; background-color: #f0f0f0; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div id="power-progress" class="progress-bar" style="width: 0%; height: 30px; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="graph-box">
                <h3>Day of Week</h3>
                <div class="plot-container" style="position: relative; min-height: 400px;">
                    <img id="histogram-plot" src="" alt="Histogram plot" style="display: none; width: 100%; height: auto;">
                    <img id="histogram-plot-new" src="" alt="Histogram plot" style="display: none; width: 100%; height: auto; position: absolute; top: 0; left: 0;">
                    <div id="histogram-loading" class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 400px;">
                        <div class="progress-bar-container" style="width: 100%; background-color: #f0f0f0; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div id="histogram-progress" class="progress-bar" style="width: 0%; height: 30px; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="event-info" id="event-info" style="display: none;">
            <p><strong>Event Index:</strong> <span id="event-index"></span></p>
            <p><strong>Timestamp:</strong> <span id="event-timestamp"></span></p>
            <p><strong>Device:</strong> <span id="event-device"></span></p>
            <p><strong>Matching Events:</strong> <span id="matching-count"></span> (distance < <span id="match-distance"></span>)</p>
        </div>
        
        <div class="browse-controls">
            <button class="btn-primary" onclick="browseAction('P')">‚óÄ Previous</button>
            <button class="btn-primary" onclick="browseAction('N')">Next ‚ñ∂</button>
            <button id="latest-btn" class="btn-primary latest-active" onclick="toggleLatest()">Latest ‚≠ê</button>
            <button class="btn-success" onclick="showSaveDeviceDialog()">Save as Device</button>
        </div>
        
        <div class="message" id="message"></div>
        
        <div class="section">
            <h2>üîå Devices</h2>
            <div id="devices-table">
                {% if devices %}
                <table id="devices-table-content">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="idx" onclick="sortTable('idx')">IDX</th>
                            <th class="sortable" data-sort="label" onclick="sortTable('label')">Label</th>
                            <th class="sortable" data-sort="on_off" onclick="sortTable('on_off')">ON/OFF</th>
                            <th class="sortable" data-sort="avg_power" onclick="sortTable('avg_power')">Avg Power</th>
                            <th class="sortable" data-sort="count" onclick="sortTable('count')">Count</th>
                            <th class="sortable" data-sort="max_distance" onclick="sortTable('max_distance')">Max Distance</th>
                            <th class="sortable" data-sort="off_delay" onclick="sortTable('off_delay')">Off Delay</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="devices-table-body">
                        {% for device in devices %}
                        <tr class="device-row" data-device-idx="{{ device.idx }}" data-sort-idx="{{ device.idx }}" data-sort-label="{{ device.label|lower }}" data-sort-on-off="{{ device.on_off }}" data-sort-avg-power="{{ device.avg_power if device.avg_power is not none else -1 }}" data-sort-count="{{ device.count }}" data-sort-max-distance="{{ device.max_distance if device.max_distance is not none else -1 }}" data-sort-off-delay="{{ device.off_delay if device.off_delay is not none else -1 }}" onclick="event.preventDefault(); loadDevicePlots({{ device.idx }});">
                            <td>{{ device.idx }}</td>
                            <td class="editable-cell" data-field="label" data-device-idx="{{ device.idx }}" onclick="handleEditableCellClick(event, this, {{ device.idx }});">
                                <span class="editable-content" ondblclick="event.stopPropagation(); makeEditable(this.parentElement);">{{ device.label }}</span>
                                <input type="text" class="editable-input" style="display: none;" value="{{ device.label }}" onblur="saveDeviceField(this, 'label')" onkeydown="if(event.key==='Enter') this.blur();" onclick="event.stopPropagation();">
                            </td>
                            <td>{{ device.on_off }}</td>
                            <td>{{ "%.2f"|format(device.avg_power) if device.avg_power is not none else "N/A" }}</td>
                            <td>{{ device.count }}</td>
                            <td class="editable-cell" data-field="max_distance" data-device-idx="{{ device.idx }}" onclick="handleEditableCellClick(event, this, {{ device.idx }});">
                                <span class="editable-content" ondblclick="event.stopPropagation(); makeEditable(this.parentElement);">{{ "%.2f"|format(device.max_distance) if device.max_distance is not none else "N/A" }}</span>
                                <input type="number" class="editable-input" style="display: none;" step="1" min="0" value="{{ device.max_distance if device.max_distance is not none else '' }}" onblur="saveDeviceField(this, 'max_distance')" onkeydown="if(event.key==='Enter') this.blur();" onclick="event.stopPropagation();">
                            </td>
                            <td class="editable-cell" data-field="off_delay" data-device-idx="{{ device.idx }}" onclick="handleEditableCellClick(event, this, {{ device.idx }});">
                                <span class="editable-content" ondblclick="event.stopPropagation(); makeEditable(this.parentElement);">{{ device.off_delay ~ " min" if device.off_delay is not none and device.off_delay >= 0 else "-" }}</span>
                                <input type="number" class="editable-input" style="display: none;" step="1" min="-1" value="{{ device.off_delay if device.off_delay is not none else -1 }}" onblur="saveDeviceField(this, 'off_delay')" onkeydown="if(event.key==='Enter') this.blur();">
                            </td>
                            <td class="delete-cell" onclick="event.stopPropagation(); deleteDevice({{ device.idx }});" style="display: none; text-align: center; cursor: pointer; color: #dc3545; font-weight: bold; font-size: 1.2em;">‚úï</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
                {% else %}
                <p>No devices found. Run an analysis first.</p>
                {% endif %}
            </div>
        </div>
        
        <div class="section">
            <h2>üìä Data Management</h2>
            <p style="color: #666; margin-bottom: 15px;">Data files are automatically monitored and reloaded when new or updated files are detected.</p>
            <div class="button-group">
                <button id="fresh-analysis-btn" class="btn-primary" onclick="freshAnalysis()">
                    {% if status.n_devices > 0 %}Start Over{% else %}Fresh Analysis{% endif %}
                </button>
                <button id="analyze-unlabeled-btn" class="btn-primary" onclick="analyzeUnlabeled()" {% if status.n_devices == 0 %}style="display: none;"{% endif %}>
                    Analyze Unlabeled Events
                </button>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing...</p>
            </div>
        </div>
        
    </div>
    
    <script>
        let currentEventIndex = null; // Simple event number (0-based index)
        let totalEvents = 0;
        let matchDistance = 500; // Remembered/global match distance
        let latestModeActive = true; // Default to active
        let updateInterval = null; // Store interval ID for auto updates
        let selectedDeviceIdx = null; // Track currently selected device
        let currentClusterIndex = null; // Current cluster being labeled
        let totalClusters = 0; // Total number of clusters
        let isLabelingMode = false; // Whether we're in cluster labeling mode
        
        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = text;
            messageDiv.className = 'message ' + type;
            messageDiv.style.display = 'block';
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        function showGraphLoading(graphId, show) {
            const loadingEl = document.getElementById(graphId + '-loading');
            if (loadingEl) {
                loadingEl.style.display = show ? 'block' : 'none';
                if (show) {
                    // Reset progress to 0 when starting
                    updateProgress(graphId, 0);
                }
            }
        }
        
        function updateProgress(graphId, progress) {
            const progressEl = document.getElementById(graphId + '-progress');
            if (progressEl) {
                const progressPercent = Math.min(100, Math.max(0, Math.round(progress)));
                progressEl.style.width = progressPercent + '%';
                progressEl.textContent = progressPercent + '%';
            }
        }
        
        function swapPlotImage(graphId) {
            const oldImg = document.getElementById(graphId + '-plot');
            const newImg = document.getElementById(graphId + '-plot-new');
            
            if (!oldImg || !newImg) return;
            
            // Swap the images
            const tempSrc = oldImg.src;
            oldImg.src = newImg.src;
            newImg.src = tempSrc;
            
            // Ensure old image is visible and new image is hidden
            if (oldImg.src) {
                oldImg.style.display = 'block';
            }
            newImg.style.display = 'none';
        }
        
        async function loadPlots(sendMatchDistance = false) {
            // Clear selected device when switching to event view
            selectedDeviceIdx = null;
            
            // Show loading indicators (overlay on existing images)
            showGraphLoading('timeline', true);
            showGraphLoading('power', true);
            showGraphLoading('histogram', true);
            
            try {
                // Build URL with event_index and optionally match_distance parameters
                let url = '/api/get_plots';
                const params = [];
                if (currentEventIndex !== null) {
                    params.push(`event_index=${currentEventIndex}`);
                }
                // Only send match_distance if explicitly requested (user manually changed it)
                // Otherwise, let backend use device's max_distance if event matches a device
                if (sendMatchDistance) {
                    const currentMatchDistance = parseFloat(document.getElementById('match-distance-input').value);
                    if (!isNaN(currentMatchDistance)) {
                        params.push(`match_distance=${currentMatchDistance}`);
                    }
                }
                if (params.length > 0) {
                    url += '?' + params.join('&');
                }
                
                // Start progress tracking
                let progressInterval = null;
                let estimatedProgress = 0;
                
                // Simulate progress updates while waiting for response
                // We'll update based on time elapsed, then use actual progress from response
                const progressStartTime = Date.now();
                const estimatedMaxTime = 3000; // Estimate max 3 seconds
                
                progressInterval = setInterval(() => {
                    const elapsed = Date.now() - progressStartTime;
                    const timeBasedProgress = Math.min(90, (elapsed / estimatedMaxTime) * 100);
                    // Use the higher of time-based or estimated progress
                    const currentProgress = Math.max(estimatedProgress, timeBasedProgress);
                    updateProgress('timeline', currentProgress);
                    updateProgress('power', currentProgress);
                    updateProgress('histogram', currentProgress);
                }, 50); // Update every 50ms
                
                const response = await fetch(url);
                const data = await response.json();
                
                // Clear progress interval
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                
                // Update with actual progress from server if available
                if (data.estimated_progress !== undefined) {
                    estimatedProgress = data.estimated_progress;
                    updateProgress('timeline', estimatedProgress);
                    updateProgress('power', estimatedProgress);
                    updateProgress('histogram', estimatedProgress);
                }
                
                if (data.success) {
                    // Preload new images in hidden elements
                    const timelineNew = document.getElementById('timeline-plot-new');
                    const powerNew = document.getElementById('power-plot-new');
                    const histogramNew = document.getElementById('histogram-plot-new');
                    
                    let loadedCount = 0;
                    const totalImages = 3;
                    
                    const onImageLoad = () => {
                        loadedCount++;
                        if (loadedCount === totalImages) {
                            // All images loaded, set progress to 100% then swap them
                            updateProgress('timeline', 100);
                            updateProgress('power', 100);
                            updateProgress('histogram', 100);
                            
                            setTimeout(() => {
                                swapPlotImage('timeline');
                                swapPlotImage('power');
                                swapPlotImage('histogram');
                                
                                // Hide loading indicators after a brief delay
                                setTimeout(() => {
                                    showGraphLoading('timeline', false);
                                    showGraphLoading('power', false);
                                    showGraphLoading('histogram', false);
                                }, 200);
                            }, 50);
                        }
                    };
                    
                    // Set up load handlers before setting src
                    timelineNew.onload = onImageLoad;
                    powerNew.onload = onImageLoad;
                    histogramNew.onload = onImageLoad;
                    
                    timelineNew.onerror = () => { loadedCount++; if (loadedCount === totalImages) onImageLoad(); };
                    powerNew.onerror = () => { loadedCount++; if (loadedCount === totalImages) onImageLoad(); };
                    histogramNew.onerror = () => { loadedCount++; if (loadedCount === totalImages) onImageLoad(); };
                    
                    // Start loading into hidden elements
                    timelineNew.src = 'data:image/png;base64,' + data.timeline;
                    powerNew.src = 'data:image/png;base64,' + data.power;
                    histogramNew.src = 'data:image/png;base64,' + data.histogram;
                    
                    // Update event info immediately
                    totalEvents = data.total_events;
                    matchDistance = data.match_distance;
                    
                    // If Latest mode is active, always use the last event
                    if (latestModeActive && totalEvents > 0) {
                        currentEventIndex = totalEvents - 1;
                    } else if (currentEventIndex === null) {
                        // Initialize to the event from server if not set
                        currentEventIndex = data.event_index;
                    } else {
                        // Use the current index, but ensure it's valid
                        if (currentEventIndex >= totalEvents) {
                            currentEventIndex = totalEvents - 1;
                        }
                        if (currentEventIndex < 0) {
                            currentEventIndex = 0;
                        }
                    }
                    
                    // Display event index (0-based)
                    document.getElementById('event-index').textContent = currentEventIndex;
                    // Format timestamp for display
                    const timestamp = new Date(data.timestamp);
                    const formattedTimestamp = formatTimestamp(timestamp);
                    document.getElementById('event-timestamp').textContent = formattedTimestamp;
                    updateTimestampInput();
                    // Display device ID and label
                    if (data.device_idx !== null && data.device_idx !== undefined && data.device_idx !== -1) {
                        const deviceText = data.device_label ? `${data.device_idx}: ${data.device_label}` : `Device ${data.device_idx}`;
                        document.getElementById('event-device').textContent = deviceText;
                    } else {
                        document.getElementById('event-device').textContent = 'no match found';
                    }
                    document.getElementById('matching-count').textContent = data.matching_count;
                    
                    // Use effective_match_distance if available (device's max_distance), otherwise use remembered match_distance
                    const displayDistance = data.effective_match_distance !== undefined ? data.effective_match_distance : matchDistance;
                    document.getElementById('match-distance').textContent = Math.round(displayDistance);
                    
                    // Always update the match distance input field to show the effective distance being used
                    // This ensures the input field reflects what's actually being used for matching
                    if (data.effective_match_distance !== undefined) {
                        document.getElementById('match-distance-input').value = Math.round(data.effective_match_distance);
                    } else {
                        // Fallback to match_distance if effective_match_distance not provided
                        document.getElementById('match-distance-input').value = Math.round(data.match_distance);
                    }
                    document.getElementById('event-info').style.display = 'block';
                } else {
                    showMessage(data.message, 'error');
                    showGraphLoading('timeline', false);
                    showGraphLoading('power', false);
                    showGraphLoading('histogram', false);
                }
            } catch (error) {
                showMessage('Error loading plots: ' + error, 'error');
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
            }
        }
        
        async function browseAction(action) {
            showGraphLoading('timeline', true);
            showGraphLoading('power', true);
            showGraphLoading('histogram', true);
            
            try {
                const response = await fetch('/api/browse_event', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({action: action})
                });
                const data = await response.json();
                if (data.success) {
                    if (data.message) {
                        showMessage(data.message, 'success');
                    }
                    // Reload plots
                    await loadPlots();
                    // Reload page if device was saved to update device list
                    if (action === 'S' || action === 'E') {
                        setTimeout(() => window.location.reload(), 1000);
                    }
                } else {
                    showMessage(data.message, 'error');
                    showGraphLoading('timeline', false);
                    showGraphLoading('power', false);
                    showGraphLoading('histogram', false);
                }
            } catch (error) {
                showMessage('Error: ' + error, 'error');
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
            }
        }
        
        async function updateMatchDistance() {
            const input = document.getElementById('match-distance-input');
            const newDistance = parseInt(input.value);
            if (!isNaN(newDistance) && newDistance > 0) {
                disableLatestMode();
                matchDistance = newDistance;  // Update remembered match distance locally
                
                // Update the global match_distance in the backend
                try {
                    const response = await fetch('/api/browse_event', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            action: 'M',
                            distance: newDistance,
                            event_index: currentEventIndex  // Ensure we use current event index
                        })
                    });
                    const data = await response.json();
                    if (!data.success) {
                        showMessage(data.message || 'Failed to update match distance', 'error');
                        // Reset to previous value on error
                        input.value = Math.round(matchDistance);
                        return;
                    }
                } catch (error) {
                    console.error('Error updating match distance:', error);
                    showMessage('Error updating match distance', 'error');
                    // Reset to previous value on error
                    input.value = Math.round(matchDistance);
                    return;
                }
                
                // If a device is selected, reload device plots with new match distance
                // Otherwise, reload event plots with the new match distance for the current event
                if (selectedDeviceIdx !== null) {
                    loadDevicePlots(selectedDeviceIdx, newDistance);
                } else {
                    // Ensure we reload plots for the current event index with new match distance
                    if (currentEventIndex !== null) {
                        loadPlots(true);  // true = send match_distance parameter, currentEventIndex is already set
                    } else {
                        loadPlots(true);  // loadPlots will handle if currentEventIndex is null
                    }
                }
            } else {
                // Reset to current value if invalid
                input.value = Math.round(matchDistance);
            }
        }
        
        function showSaveDeviceDialog() {
            disableLatestMode();
            const name = prompt('Enter device name:');
            if (name) {
                // Get the current match distance from input field
                const matchDistance = parseFloat(document.getElementById('match-distance-input').value);
                
                // Save device using current event index and match distance
                if (currentEventIndex !== null && !isNaN(matchDistance)) {
                    saveDeviceFromEvent(currentEventIndex, matchDistance, name);
                } else {
                    showMessage('Unable to save device: invalid event index or match distance', 'error');
                }
            }
        }
        
        async function saveDeviceFromEvent(eventIndex, matchDistance, deviceName) {
            try {
                showGraphLoading('timeline', true);
                showGraphLoading('power', true);
                showGraphLoading('histogram', true);
                
                const response = await fetch('/api/save_device', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: deviceName,
                        event_index: eventIndex,
                        match_distance: matchDistance
                    })
                });
                
                const data = await response.json();
                
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
                
                if (data.success) {
                    showMessage(data.message || `Device "${deviceName}" saved successfully`, 'success');
                    // Reload the page to show the new device in the table
                    setTimeout(() => window.location.reload(), 1000);
                } else {
                    showMessage(data.message || 'Failed to save device', 'error');
                }
            } catch (error) {
                console.error('Error saving device:', error);
                showMessage('Error saving device: ' + error, 'error');
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
            }
        }
        
        // Fix browseAction to handle additional data
        const originalBrowseAction = browseAction;
        browseAction = async function(action, extraData = {}) {
            // Disable latest mode on any user interaction (except Latest button itself)
            if (action !== 'L') {
                disableLatestMode();
            }
            
            // When navigating (Previous/Next), don't send match_distance parameter
            // This allows the backend to use device's max_distance if event matches a device
            // The input field will be updated after loadPlots() completes
            
            // Handle Latest locally (server handles P/N)
            if (action === 'L') {
                // Latest: set to last event
                if (totalEvents > 0) {
                    currentEventIndex = totalEvents - 1;
                    updateTimestampInput();
                }
            }
            // Note: P (Previous) and N (Next) are handled on the server side
            
            showGraphLoading('timeline', true);
            showGraphLoading('power', true);
            showGraphLoading('histogram', true);
            
            try {
                const response = await fetch('/api/browse_event', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: action, 
                        event_index: currentEventIndex,
                        ...extraData
                    })
                });
                const data = await response.json();
                if (data.success) {
                    if (data.message) {
                        showMessage(data.message, 'success');
                    }
                    // Update currentEventIndex from server response if provided
                    if (data.event_index !== undefined) {
                        currentEventIndex = data.event_index;
                        updateTimestampInput();
                    }
                    // For save/edit actions, reload immediately without loading plots
                    if (action === 'S' || action === 'E') {
                        // Hide loading indicators before reload
                        showGraphLoading('timeline', false);
                        showGraphLoading('power', false);
                        showGraphLoading('histogram', false);
                        setTimeout(() => window.location.reload(), 1000);
                    } else {
                        // For other actions (P, N, etc.), load plots normally
                        await loadPlots();
                    }
                } else {
                    showMessage(data.message, 'error');
                    // Hide loading indicators on error
                    showGraphLoading('timeline', false);
                    showGraphLoading('power', false);
                    showGraphLoading('histogram', false);
                    showGraphLoading('timeline', false);
                    showGraphLoading('power', false);
                    showGraphLoading('histogram', false);
                }
            } catch (error) {
                showMessage('Error: ' + error, 'error');
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
            }
        };
        
        async function freshAnalysis() {
            // Check if there are devices (button text indicates this)
            const btn = document.getElementById('fresh-analysis-btn');
            const hasDevices = btn && btn.textContent.trim() === 'Start Over';
            
            if (hasDevices) {
                // Show warning dialog
                const confirmed = confirm(
                    '‚ö†Ô∏è WARNING: Starting over will erase all existing devices!\n\n' +
                    'This action cannot be undone. All your device labels, profiles, and settings will be lost.\n\n' +
                    'Are you sure you want to continue?'
                );
                
                if (!confirmed) {
                    return; // User cancelled
                }
            }
            
            // Stop auto updates
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            latestModeActive = false;
            
            // Clear the page content
            const container = document.querySelector('.container');
            container.innerHTML = '<div class="loading" style="display: block;"><div class="spinner"></div><p>Running analysis...</p></div>';
            
            try {
                const response = await fetch('/api/fresh_analysis', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    totalClusters = data.n_clusters;
                    currentClusterIndex = 0;
                    isLabelingMode = true;
                    // Show cluster labeling interface
                    showClusterLabelingInterface();
                    loadClusterPlots(0);
                } else {
                    showMessage(data.message, 'error');
                    // Reload page on error
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                }
            } catch (error) {
                showMessage('Error running analysis: ' + error, 'error');
                // Reload page on error
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }
        }
        
        async function analyzeUnlabeled() {
            // Stop auto updates
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            latestModeActive = false;
            
            // Clear the page content
            const container = document.querySelector('.container');
            container.innerHTML = '<div class="loading" style="display: block;"><div class="spinner"></div><p>Analyzing unlabeled events...</p></div>';
            
            try {
                const response = await fetch('/api/analyze_unlabeled', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    totalClusters = data.n_clusters;
                    currentClusterIndex = 0;
                    isLabelingMode = true;
                    // Show cluster labeling interface
                    showClusterLabelingInterface();
                    loadClusterPlots(0);
                } else {
                    showMessage(data.message, 'error');
                    // Reload page on error
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                }
            } catch (error) {
                showMessage('Error analyzing unlabeled events: ' + error, 'error');
                // Reload page on error
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }
        }
        
        function showClusterLabelingInterface() {
            const container = document.querySelector('.container');
            container.innerHTML = `
                <h1>üè∑Ô∏è Identify Clusters as Devices</h1>
                <p class="subtitle">Review each cluster and label it as a device, or skip to the next one.</p>
                
                <div class="status-bar">
                    <div class="status-card">
                        <div class="label">Cluster</div>
                        <div class="value" id="cluster-number">-</div>
                    </div>
                    <div class="status-card">
                        <div class="label">Events in Cluster</div>
                        <div class="value" id="cluster-count">-</div>
                    </div>
                    <div class="status-card">
                        <div class="label">Current Label</div>
                        <div class="value" id="cluster-label">-</div>
                    </div>
                </div>
                
                <div class="graphs-container">
                    <div class="graph-box">
                        <h3>Timeline</h3>
                        <img id="timeline-img" src="" alt="Timeline" style="display: none;">
                        <div class="loading" id="timeline-loading" style="display: block;">
                            <div class="spinner"></div>
                            <p>Loading...</p>
                        </div>
                    </div>
                    <div class="graph-box">
                        <h3>Power Pattern</h3>
                        <img id="power-img" src="" alt="Power" style="display: none;">
                        <div class="loading" id="power-loading" style="display: block;">
                            <div class="spinner"></div>
                            <p>Loading...</p>
                        </div>
                    </div>
                    <div class="graph-box">
                        <h3>Day of Week</h3>
                        <img id="histogram-img" src="" alt="Histogram" style="display: none;">
                        <div class="loading" id="histogram-loading" style="display: block;">
                            <div class="spinner"></div>
                            <p>Loading...</p>
                        </div>
                    </div>
                </div>
                
                <div class="browse-controls">
                    <button class="btn-success" onclick="labelCluster()">Label as Device</button>
                    <button class="btn-primary" onclick="skipCluster()">Skip</button>
                    <button class="btn-warning" onclick="completeLabeling()">Complete</button>
                </div>
                
                <div class="message" id="message"></div>
            `;
        }
        
        async function loadClusterPlots(clusterId) {
            try {
                // Update cluster info
                const infoResponse = await fetch(`/api/get_cluster_info?cluster_id=${clusterId}`);
                const infoData = await infoResponse.json();
                
                if (infoData.success) {
                    document.getElementById('cluster-number').textContent = `${clusterId} of ${totalClusters - 1}`;
                    document.getElementById('cluster-count').textContent = infoData.cluster_count;
                    document.getElementById('cluster-label').textContent = infoData.cluster_label || 'Unlabeled';
                }
                
                // Load plots
                const plotsResponse = await fetch(`/api/get_cluster_plots?cluster_id=${clusterId}`);
                const plotsData = await plotsResponse.json();
                
                if (plotsData.success) {
                    // Update images
                    const timelineImg = document.getElementById('timeline-img');
                    const powerImg = document.getElementById('power-img');
                    const histogramImg = document.getElementById('histogram-img');
                    
                    timelineImg.src = 'data:image/png;base64,' + plotsData.timeline;
                    powerImg.src = 'data:image/png;base64,' + plotsData.power;
                    histogramImg.src = 'data:image/png;base64,' + plotsData.histogram;
                    
                    // Show images and hide loading
                    timelineImg.style.display = 'block';
                    powerImg.style.display = 'block';
                    histogramImg.style.display = 'block';
                    document.getElementById('timeline-loading').style.display = 'none';
                    document.getElementById('power-loading').style.display = 'none';
                    document.getElementById('histogram-loading').style.display = 'none';
                } else {
                    showMessage(plotsData.message || 'Error loading plots', 'error');
                }
            } catch (error) {
                showMessage('Error loading cluster: ' + error, 'error');
            }
        }
        
        async function labelCluster() {
            const label = prompt(`Enter a label for Cluster ${currentClusterIndex}:`);
            if (!label || !label.trim()) {
                return; // User cancelled or entered empty label
            }
            
            try {
                const response = await fetch('/api/label_cluster', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        cluster_id: currentClusterIndex,
                        label: label.trim()
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    showMessage(data.message, 'success');
                    // Update cluster label display
                    document.getElementById('cluster-label').textContent = label.trim();
                    // Move to next cluster
                    nextCluster();
                } else {
                    showMessage(data.message, 'error');
                }
            } catch (error) {
                showMessage('Error labeling cluster: ' + error, 'error');
            }
        }
        
        function skipCluster() {
            nextCluster();
        }
        
        function nextCluster() {
            if (currentClusterIndex < totalClusters - 1) {
                currentClusterIndex++;
                // Reset loading indicators
                document.getElementById('timeline-img').style.display = 'none';
                document.getElementById('power-img').style.display = 'none';
                document.getElementById('histogram-img').style.display = 'none';
                document.getElementById('timeline-loading').style.display = 'block';
                document.getElementById('power-loading').style.display = 'block';
                document.getElementById('histogram-loading').style.display = 'block';
                loadClusterPlots(currentClusterIndex);
            } else {
                // Reached the last cluster, complete labeling
                completeLabeling();
            }
        }
        
        async function completeLabeling() {
            try {
                const response = await fetch('/api/complete_labeling', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    showMessage(data.message, 'success');
                    // Reload page like at start of program
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } else {
                    showMessage(data.message, 'error');
                }
            } catch (error) {
                showMessage('Error completing labeling: ' + error, 'error');
            }
        }
        
        function formatTimestamp(date) {
            // Format date as "Jan 5, 4:03am TZ" or similar with timezone
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return '';
            }
            
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            let hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'pm' : 'am';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            const minutesStr = minutes < 10 ? '0' + minutes : minutes;
            
            // Get timezone information
            let timezoneStr = '';
            try {
                // Try to get timezone name (e.g., "PST", "EST")
                const timezoneName = Intl.DateTimeFormat('en', { timeZoneName: 'short' }).formatToParts(date)
                    .find(part => part.type === 'timeZoneName');
                if (timezoneName && timezoneName.value) {
                    timezoneStr = ' ' + timezoneName.value;
                } else {
                    // Fallback to offset (e.g., "-08:00")
                    const offset = -date.getTimezoneOffset();
                    const offsetHours = Math.floor(Math.abs(offset) / 60);
                    const offsetMinutes = Math.abs(offset) % 60;
                    const offsetSign = offset >= 0 ? '+' : '-';
                    timezoneStr = ` ${offsetSign}${String(offsetHours).padStart(2, '0')}:${String(offsetMinutes).padStart(2, '0')}`;
                }
            } catch (e) {
                // If timezone detection fails, try offset
                try {
                    const offset = -date.getTimezoneOffset();
                    const offsetHours = Math.floor(Math.abs(offset) / 60);
                    const offsetMinutes = Math.abs(offset) % 60;
                    const offsetSign = offset >= 0 ? '+' : '-';
                    timezoneStr = ` ${offsetSign}${String(offsetHours).padStart(2, '0')}:${String(offsetMinutes).padStart(2, '0')}`;
                } catch (e2) {
                    // If all else fails, leave timezone empty
                    timezoneStr = '';
                }
            }
            
            return `${month} ${day}, ${hours}:${minutesStr}${ampm}${timezoneStr}`;
        }
        
        function formatTimestampWithTimezone(date) {
            // Format date as "YYYY-MM-DD HH:MM:SS TZ" for status cards
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return 'N/A';
            }
            
            // Format date and time
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            let hours = date.getHours();
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            
            // Get timezone information
            let timezoneStr = '';
            try {
                // Try to get timezone name (e.g., "PST", "EST")
                const timezoneName = Intl.DateTimeFormat('en', { timeZoneName: 'short' }).formatToParts(date)
                    .find(part => part.type === 'timeZoneName');
                if (timezoneName && timezoneName.value) {
                    timezoneStr = ' ' + timezoneName.value;
                } else {
                    // Fallback to offset (e.g., "-08:00")
                    const offset = -date.getTimezoneOffset();
                    const offsetHours = Math.floor(Math.abs(offset) / 60);
                    const offsetMinutes = Math.abs(offset) % 60;
                    const offsetSign = offset >= 0 ? '+' : '-';
                    timezoneStr = ` ${offsetSign}${String(offsetHours).padStart(2, '0')}:${String(offsetMinutes).padStart(2, '0')}`;
                }
            } catch (e) {
                // If timezone detection fails, try offset
                try {
                    const offset = -date.getTimezoneOffset();
                    const offsetHours = Math.floor(Math.abs(offset) / 60);
                    const offsetMinutes = Math.abs(offset) % 60;
                    const offsetSign = offset >= 0 ? '+' : '-';
                    timezoneStr = ` ${offsetSign}${String(offsetHours).padStart(2, '0')}:${String(offsetMinutes).padStart(2, '0')}`;
                } catch (e2) {
                    // If all else fails, leave timezone empty
                    timezoneStr = '';
                }
            }
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}${timezoneStr}`;
        }
        
        function updateTimestampInput() {
            // Update the timestamp input field to show current event timestamp
            const timestampInput = document.getElementById('timestamp-input');
            if (timestampInput && currentEventIndex !== null) {
                // Only update if the input doesn't have focus (user isn't editing it)
                if (document.activeElement !== timestampInput) {
                    // Get timestamp from the event info display
                    const timestampSpan = document.getElementById('event-timestamp');
                    if (timestampSpan && timestampSpan.textContent) {
                        timestampInput.value = timestampSpan.textContent;
                    }
                }
            }
        }
        
        async function updateEventFromTimestamp() {
            // User changed the timestamp input - find nearest event
            const timestampInput = document.getElementById('timestamp-input');
            if (!timestampInput) return;
            
            const timestampStr = timestampInput.value.trim();
            if (!timestampStr) {
                // Empty - reset to current
                updateTimestampInput();
                return;
            }
            
            try {
                // Send timestamp to backend to find nearest event
                const response = await fetch(`/api/find_event_by_timestamp?timestamp=${encodeURIComponent(timestampStr)}`);
                const data = await response.json();
                
                if (data.success) {
                    currentEventIndex = data.event_index;
                    // Disable latest mode when user manually changes timestamp
                    disableLatestMode();
                    updateTimestampInput();
                    loadPlots();
                } else {
                    showMessage(data.message || 'Could not find event for that timestamp', 'error');
                    // Reset to current timestamp
                    updateTimestampInput();
                }
            } catch (error) {
                showMessage('Error finding event: ' + error, 'error');
                updateTimestampInput();
            }
        }
        
        async function toggleLatest() {
            latestModeActive = !latestModeActive;
            const btn = document.getElementById('latest-btn');
            if (latestModeActive) {
                btn.classList.add('latest-active');
                btn.textContent = 'Latest ‚≠ê';
                // When Latest is enabled, set to the last event and notify server
                // Restore the remembered match distance
                document.getElementById('match-distance-input').value = Math.round(matchDistance);
                if (totalEvents > 0) {
                    currentEventIndex = totalEvents - 1;
                    updateTimestampInput();
                    // Notify server to set mode to 'monitor'
                    try {
                        await fetch('/api/browse_event', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({
                                action: 'L',
                                event_index: currentEventIndex
                            })
                        });
                    } catch (error) {
                        console.error('Error setting monitor mode:', error);
                    }
                    loadPlots();
                } else if (currentEventIndex === null) {
                    // If totalEvents not yet loaded, loadPlots will handle it
                    loadPlots();
                }
            } else {
                btn.classList.remove('latest-active');
                btn.textContent = 'Latest';
            }
        }
        
        
        async function deleteDevice(device_idx) {
            const deviceRow = document.querySelector(`.device-row[data-device-idx="${device_idx}"]`);
            const deviceLabel = deviceRow ? deviceRow.querySelector('.editable-content').textContent : `Device ${device_idx}`;
            
            if (!confirm(`Are you sure you want to delete device "${deviceLabel}" (ID: ${device_idx})?`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/delete_device', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ device_idx: device_idx })
                });
                
                const data = await response.json();
                if (data.success) {
                    showMessage(data.message, 'success');
                    // Reload page to update device list
                    setTimeout(() => window.location.reload(), 1000);
                } else {
                    showMessage(data.message || 'Failed to delete device', 'error');
                }
            } catch (error) {
                console.error('Error deleting device:', error);
                showMessage('Error deleting device', 'error');
            }
        }
        
        function disableLatestMode() {
            if (latestModeActive) {
                latestModeActive = false;
                const btn = document.getElementById('latest-btn');
                btn.classList.remove('latest-active');
                btn.textContent = 'Latest';
            }
        }
        
        // Poll for data updates
        async function checkForUpdates() {
            // Only check for updates if latest mode is active and not in labeling mode
            if (!latestModeActive || isLabelingMode) {
                return; // Exit early if latest mode is disabled or in labeling mode
            }
            
            try {
                const response = await fetch('/api/check_updates');
                const data = await response.json();
                
                // Check again after async operation - state might have changed
                if (!latestModeActive) {
                    return;
                }
                
                if (data.success) {
                    const currentEventCount = parseInt(document.getElementById('status-events').textContent);
                    if (data.has_update || data.event_count !== currentEventCount) {
                        // Final check before updating - state might have changed during async operations
                        if (!latestModeActive) {
                            return;
                        }
                        
                        // Update event count in "0 to n-1" format
                        if (data.event_count === 0) {
                            document.getElementById('status-events').textContent = '0';
                        } else {
                            const maxIndex = data.event_count - 1;
                            document.getElementById('status-events').textContent = `0 to ${maxIndex}`;
                        }
                        // Update device count if changed
                        const currentDeviceCount = parseInt(document.getElementById('status-devices').textContent);
                        // Update "Data Since" timestamp if provided
                        if (data.first_event_timestamp) {
                            // Convert ISO timestamp to local time with timezone
                            const firstEventDate = new Date(data.first_event_timestamp);
                            const formattedFirstEvent = formatTimestampWithTimezone(firstEventDate);
                            document.getElementById('status-data-since').textContent = formattedFirstEvent;
                        }
                        if (data.device_count !== currentDeviceCount) {
                            // Reload page to get updated device list
                            window.location.reload();
                        } else {
                            // Just reload plots to show latest event
                            // When Latest mode is active and has_update is true, update to the last event
                            if (latestModeActive && data.has_update && data.event_count > 0) {
                                // Update totalEvents and currentEventIndex to latest before loading plots
                                totalEvents = data.event_count;
                                currentEventIndex = data.event_count - 1;
                                updateTimestampInput();
                                console.log(`üîÑ Latest mode: Updating to event ${currentEventIndex} of ${totalEvents}`);
                            }
                            // loadPlots() will use the updated currentEventIndex and will also ensure
                            // it's set to latest if latestModeActive is still true
                            loadPlots();
                        }
                    }
                }
            } catch (error) {
                // Silently fail - don't spam errors for polling
                console.error('Polling error:', error);
            }
        }
        
        // Update device count on page load if devices are shown
        window.addEventListener('load', () => {
            // Format initial "Data Since" timestamp if present
            const statusDataSince = document.getElementById('status-data-since');
            if (statusDataSince) {
                const isoTimestamp = statusDataSince.getAttribute('data-iso-timestamp');
                if (isoTimestamp) {
                    try {
                        const firstEventDate = new Date(isoTimestamp);
                        if (!isNaN(firstEventDate.getTime())) {
                            statusDataSince.textContent = formatTimestampWithTimezone(firstEventDate);
                        }
                    } catch (e) {
                        // If parsing fails, leave as is
                    }
                }
            }
            const devicesTable = document.getElementById('devices-table');
            const table = devicesTable.querySelector('table');
            if (table) {
                const rows = table.querySelectorAll('tbody tr');
                document.getElementById('status-devices').textContent = rows.length;
            }
            // Initialize Latest button state
            const latestBtn = document.getElementById('latest-btn');
            if (latestModeActive) {
                latestBtn.classList.add('latest-active');
                latestBtn.textContent = 'Latest ‚≠ê';
            }
            // Set up match distance input handler
            const matchDistanceInput = document.getElementById('match-distance-input');
            matchDistanceInput.addEventListener('change', updateMatchDistance);
            matchDistanceInput.addEventListener('blur', updateMatchDistance);
            // Also update on Enter key
            matchDistanceInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    updateMatchDistance();
                    this.blur();
                }
            });
            
            // Load plots on page load
            loadPlots();
            
            // Start polling for updates every 20 seconds
            updateInterval = setInterval(checkForUpdates, 20000);
        });
        
        // Device table sorting
        let currentSortColumn = null;
        let currentSortDirection = 'asc'; // 'asc' or 'desc'
        
        function sortTable(column) {
            const tbody = document.getElementById('devices-table-body');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Toggle direction if clicking the same column
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }
            
            // Remove sort classes from all headers
            document.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add sort class to current header
            const header = document.querySelector(`th[data-sort="${column}"]`);
            if (header) {
                header.classList.add(`sort-${currentSortDirection}`);
            }
            
            // Sort rows
            rows.sort((a, b) => {
                // Convert column name with underscores to hyphenated attribute name
                const attrName = `data-sort-${column.replace(/_/g, '-')}`;
                let aValue = a.getAttribute(attrName);
                let bValue = b.getAttribute(attrName);
                
                // Handle numeric columns
                if (column === 'idx' || column === 'avg_power' || column === 'count' || column === 'max_distance' || column === 'off_delay') {
                    aValue = parseFloat(aValue);
                    bValue = parseFloat(bValue);
                    // Handle -1 as "not available" (should sort last)
                    if (aValue === -1 && bValue === -1) return 0;
                    if (aValue === -1) return 1;
                    if (bValue === -1) return -1;
                } else if (column === 'on_off') {
                    // Special sorting for ON/OFF: ON comes before OFF, N/A comes last
                    const order = {'ON': 0, 'OFF': 1, 'N/A': 2};
                    const aOrder = order[aValue] !== undefined ? order[aValue] : 3;
                    const bOrder = order[bValue] !== undefined ? order[bValue] : 3;
                    aValue = aOrder;
                    bValue = bOrder;
                }
                
                // Compare values
                let comparison = 0;
                if (aValue < bValue) {
                    comparison = -1;
                } else if (aValue > bValue) {
                    comparison = 1;
                }
                
                // Reverse if descending
                return currentSortDirection === 'asc' ? comparison : -comparison;
            });
            
            // Re-append rows in sorted order
            rows.forEach(row => tbody.appendChild(row));
        }
        
        // Device table functions
        let currentlyEditing = null; // Track which input is currently being edited
        let editClickTimeout = null; // Track timeout for edit mode
        
        function handleEditableCellClick(event, cell, device_idx) {
            // If clicking on the input field itself, don't do anything (let input handle it)
            if (event.target.classList.contains('editable-input')) {
                event.stopPropagation();
                return;
            }
            
            // If clicking on content that's already visible (not editing), load device first
            const input = cell.querySelector('.editable-input');
            const content = cell.querySelector('.editable-content');
            
            if (input && input.style.display === 'none' && content && content.style.display !== 'none') {
                // Content is visible, so this is a single click - load device plots
                // Let the event bubble to the row click handler
                // Don't prevent propagation - let it load the device
                return;
            }
            
            // Otherwise, if we're in edit mode or something else, prevent default behavior
            event.stopPropagation();
            event.preventDefault();
        }
        
        function makeEditable(cell) {
            // Close any other open edits first
            if (currentlyEditing && currentlyEditing !== cell) {
                const otherInput = currentlyEditing.querySelector('.editable-input');
                if (otherInput && otherInput.style.display !== 'none') {
                    otherInput.blur();
                }
            }
            
            const content = cell.querySelector('.editable-content');
            const input = cell.querySelector('.editable-input');
            if (content && input) {
                currentlyEditing = cell;
                content.style.display = 'none';
                input.style.display = 'inline-block';
                input.focus();
                input.select();
                // Store original value for comparison
                input.dataset.originalValue = input.value;
            }
        }
        
        async function saveDeviceField(input, fieldName) {
            const cell = input.closest('.editable-cell');
            const content = cell.querySelector('.editable-content');
            const device_idx = parseInt(cell.getAttribute('data-device-idx'));
            let newValue = input.value.trim();
            const originalValue = input.dataset.originalValue || '';
            
            // Check if value actually changed
            let valueChanged = false;
            if (fieldName === 'max_distance') {
                const originalNum = parseFloat(originalValue) || 0;
                newValue = parseFloat(newValue);
                if (isNaN(newValue) || newValue <= 0) {
                    // Reset to original value
                    input.value = originalValue;
                    input.style.display = 'none';
                    content.style.display = 'inline-block';
                    currentlyEditing = null;
                    return;
                }
                valueChanged = Math.abs(newValue - originalNum) > 0.01;
            } else if (fieldName === 'off_delay') {
                const originalNum = parseInt(originalValue) || -1;
                newValue = parseInt(newValue);
                if (isNaN(newValue)) {
                    newValue = -1;
                }
                valueChanged = newValue !== originalNum;
            } else {
                // For label, compare strings
                valueChanged = newValue !== originalValue;
            }
            
            // Close the input
            input.style.display = 'none';
            content.style.display = 'inline-block';
            currentlyEditing = null;
            
            // Only save if value actually changed
            if (!valueChanged) {
                return;
            }
            
            // Update display immediately
            if (fieldName === 'off_delay') {
                content.textContent = newValue >= 0 ? newValue + ' min' : '-';
            } else if (fieldName === 'max_distance') {
                content.textContent = newValue.toFixed(2);
            } else {
                content.textContent = newValue;
            }
            
            // Save to backend
            try {
                const updateData = { device_idx: device_idx };
                updateData[fieldName] = newValue;
                
                const response = await fetch('/api/update_device', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(updateData)
                });
                
                const data = await response.json();
                if (data.success) {
                    showMessage(data.message, 'success');
                    // If max_distance changed, reload device plots if this device is selected
                    if (fieldName === 'max_distance') {
                        const selectedRow = document.querySelector('.device-row.selected');
                        if (selectedRow && parseInt(selectedRow.getAttribute('data-device-idx')) === device_idx) {
                            loadDevicePlots(device_idx);
                        }
                    }
                } else {
                    showMessage(data.message || 'Failed to update device', 'error');
                    // Revert on error
                    window.location.reload();
                }
            } catch (error) {
                console.error('Error updating device:', error);
                showMessage('Error updating device', 'error');
                window.location.reload();
            }
        }
        
        async function loadDevicePlots(device_idx, matchDistanceOverride = null) {
            console.log('loadDevicePlots called with device_idx:', device_idx);
            
            // Store selected device ID
            selectedDeviceIdx = device_idx;
            
            // Close any open edits first
            if (currentlyEditing) {
                const input = currentlyEditing.querySelector('.editable-input');
                if (input && input.style.display !== 'none') {
                    // Cancel any pending save operations
                    input.onblur = null;
                    input.style.display = 'none';
                    const content = currentlyEditing.querySelector('.editable-content');
                    if (content) {
                        content.style.display = 'inline-block';
                    }
                    currentlyEditing = null;
                    // Small delay to ensure UI updates
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            // Disable latest mode when viewing a device
            disableLatestMode();
            
            // Update selected row
            document.querySelectorAll('.device-row').forEach(row => {
                row.classList.remove('selected');
            });
            const selectedRow = document.querySelector(`.device-row[data-device-idx="${device_idx}"]`);
            if (selectedRow) {
                selectedRow.classList.add('selected');
            }
            
            // Show loading indicators
            showGraphLoading('timeline', true);
            showGraphLoading('power', true);
            showGraphLoading('histogram', true);
            
            try {
                console.log('Fetching device plots for device:', device_idx);
                let url = `/api/get_device_plots?device_idx=${device_idx}`;
                if (matchDistanceOverride !== null) {
                    url += `&match_distance=${matchDistanceOverride}`;
                }
                
                // Start progress tracking
                let progressInterval = null;
                let estimatedProgress = 0;
                
                // Simulate progress updates while waiting for response
                // We'll update based on time elapsed, then use actual progress from response
                const progressStartTime = Date.now();
                const estimatedMaxTime = 3000; // Estimate max 3 seconds
                
                progressInterval = setInterval(() => {
                    const elapsed = Date.now() - progressStartTime;
                    const timeBasedProgress = Math.min(90, (elapsed / estimatedMaxTime) * 100);
                    // Use the higher of time-based or estimated progress
                    const currentProgress = Math.max(estimatedProgress, timeBasedProgress);
                    updateProgress('timeline', currentProgress);
                    updateProgress('power', currentProgress);
                    updateProgress('histogram', currentProgress);
                }, 50); // Update every 50ms
                
                const response = await fetch(url);
                const data = await response.json();
                
                // Clear progress interval
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                
                // Update with actual progress from server if available
                if (data.estimated_progress !== undefined) {
                    estimatedProgress = data.estimated_progress;
                    updateProgress('timeline', estimatedProgress);
                    updateProgress('power', estimatedProgress);
                    updateProgress('histogram', estimatedProgress);
                }
                
                console.log('Device plots response:', data.success ? 'success' : 'failed', data);
                
                if (data.success) {
                    // Preload new images in hidden elements
                    const timelineNew = document.getElementById('timeline-plot-new');
                    const powerNew = document.getElementById('power-plot-new');
                    const histogramNew = document.getElementById('histogram-plot-new');
                    
                    // Reset images to ensure onload fires (clear previous src)
                    timelineNew.src = '';
                    powerNew.src = '';
                    histogramNew.src = '';
                    
                    // Wait a moment for src to clear
                    await new Promise(resolve => setTimeout(resolve, 10));
                    
                    let loadedCount = 0;
                    const totalImages = 3;
                    let imagesSwapped = false;
                    
                    const swapImages = () => {
                        if (imagesSwapped) return;
                        imagesSwapped = true;
                        console.log('Swapping images');
                        swapPlotImage('timeline');
                        swapPlotImage('power');
                        swapPlotImage('histogram');
                        
                        // Hide loading indicators
                        showGraphLoading('timeline', false);
                        showGraphLoading('power', false);
                        showGraphLoading('histogram', false);
                    };
                    
                    const onImageLoad = () => {
                        loadedCount++;
                        console.log('Image loaded, count:', loadedCount, '/', totalImages);
                        if (loadedCount === totalImages) {
                            // All images loaded, set progress to 100% then swap them
                            updateProgress('timeline', 100);
                            updateProgress('power', 100);
                            updateProgress('histogram', 100);
                            
                            setTimeout(swapImages, 50);
                        }
                    };
                    
                    // Remove any existing event handlers
                    timelineNew.onload = null;
                    powerNew.onload = null;
                    histogramNew.onload = null;
                    timelineNew.onerror = null;
                    powerNew.onerror = null;
                    histogramNew.onerror = null;
                    
                    // Set up load handlers before setting src
                    timelineNew.onload = onImageLoad;
                    powerNew.onload = onImageLoad;
                    histogramNew.onload = onImageLoad;
                    
                    timelineNew.onerror = () => { 
                        console.log('Timeline image error');
                        loadedCount++; 
                        if (loadedCount === totalImages) onImageLoad(); 
                    };
                    powerNew.onerror = () => { 
                        console.log('Power image error');
                        loadedCount++; 
                        if (loadedCount === totalImages) onImageLoad(); 
                    };
                    histogramNew.onerror = () => { 
                        console.log('Histogram image error');
                        loadedCount++; 
                        if (loadedCount === totalImages) onImageLoad(); 
                    };
                    
                    // Set images
                    timelineNew.src = 'data:image/png;base64,' + data.timeline;
                    powerNew.src = 'data:image/png;base64,' + data.power;
                    histogramNew.src = 'data:image/png;base64,' + data.histogram;
                    
                    // Check if images are already loaded (for cached/instant loads)
                    setTimeout(() => {
                        let alreadyLoaded = 0;
                        if (timelineNew.complete && timelineNew.naturalWidth > 0) alreadyLoaded++;
                        if (powerNew.complete && powerNew.naturalWidth > 0) alreadyLoaded++;
                        if (histogramNew.complete && histogramNew.naturalWidth > 0) alreadyLoaded++;
                        
                        console.log('Images complete check:', alreadyLoaded, '/', totalImages);
                        
                        if (alreadyLoaded === totalImages && !imagesSwapped) {
                            console.log('All images already loaded, swapping immediately');
                            loadedCount = totalImages;
                            swapImages();
                        } else if (loadedCount < totalImages) {
                            // Fallback timeout - if images don't load within 3 seconds, swap anyway
                            setTimeout(() => {
                                if (!imagesSwapped) {
                                    console.log('Timeout: swapping images anyway, loaded:', loadedCount);
                                    loadedCount = totalImages;
                                    swapImages();
                                }
                            }, 3000);
                        }
                    }, 200);
                    
                    // Update event info to show device info
                    document.getElementById('event-index').textContent = `Device ${device_idx}`;
                    document.getElementById('event-timestamp').textContent = '';
                    if (device_idx !== null && device_idx !== undefined && device_idx !== -1) {
                        document.getElementById('event-device').textContent = data.device_label || `Device ${device_idx}`;
                    } else {
                        document.getElementById('event-device').textContent = 'no match found';
                    }
                    document.getElementById('matching-count').textContent = data.matching_count;
                    // Use effective_distance if available (when match_distance override was used), otherwise use max_distance
                    const displayDistance = data.effective_distance !== undefined ? data.effective_distance : data.max_distance;
                    document.getElementById('match-distance').textContent = Math.round(displayDistance);
                    document.getElementById('match-distance-input').value = Math.round(displayDistance);
                    document.getElementById('event-info').style.display = 'block';
                } else {
                    showMessage(data.message || 'Failed to load device plots', 'error');
                    showGraphLoading('timeline', false);
                    showGraphLoading('power', false);
                    showGraphLoading('histogram', false);
                }
            } catch (error) {
                console.error('Error loading device plots:', error);
                showMessage('Error loading device plots', 'error');
                showGraphLoading('timeline', false);
                showGraphLoading('power', false);
                showGraphLoading('histogram', false);
            }
        }
    </script>
</body>
</html>
